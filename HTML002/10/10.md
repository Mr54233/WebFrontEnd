# 10
## 删除元素对象
`父元素对象.removeChild(目标对象)`
功能 : 从父元素的子元素中删除掉目标对象 , 返回目标对象. 
### 案例1
- 单击删除按钮 , 从无序列表中删除第一个子元素li
### 案例2
- 改进留言板案例 , 在每条留言后添加一个"删除"超链接 , 单击"删除"超链接 , 则删除所在的这条留言
## 克隆元素对象

## 新增元素对象的三种方式
### `document,write()`
`document,write()`创建元素 , 如果页面文档流加载完毕 , 再调用这个方法会导致页面重绘
### `innerHTML`
### `document.createElement()`

## 事件注册的两种方式
给元素添加事件 , 称为注册事件或绑定事件
注册事件有两种方式 , `传统方式`和`监听注册方法`
### 传统注册事件
- 利用on开头的事件onclick
- `<button onclick ="alert('hi')"></button>`
### 监听注册方式

### 事件监听
#### addEventListener()事件监听
addEventListener()事件监听 (IE9以后支持)
eventSource.addEventListener(type , listener [,userCapture])
- eventSource : 事件源对象
- type:事件类型字符串 , 即事件名 (前面没有on) , 如click
- listener : 事件处理函数
- userCapture : 可选参数 , 是一个布尔值 , 默认是false , 代表默认是事件冒泡.

#### attachEvent()事件监听
attachEvent()事件监听(IE678支持)
eventSource.attacheEvnet(eventNameWithOn , callback)
- eventSource : 事件源对象
- eventNameWithOn : 事件类型字符串 , 即事件名 , 如onclick
- callback : 事件处理函数

#### 注册事件的浏览器兼容性解决方法
```js
function addEventListener(element , type , callback , userCapture)
// 1. 优先使用标准化支持的方式 , 条件 , 浏览器支持
if ( element.addEventListener){
    element.addEventListener(type,callback,userCapture);
} else if(element.attacheEvent){
    element.attacheEvent('on' + type , callback);
} else {
    element['on' + type] = callback;
}
```
## 事件冒泡和事件捕获
### DOM事件流
问题提出:
html中的标签都是相互嵌套的 , 我们可以将元素想象成一个盒子装一个盒子 , document是最外面的大盒子 . 当你单击一个div时 , 同时你也单击了div的父元素 , 甚至整个页面 .
那么是先执行父元素的单击事件 , 还是先执行div的单击事件
`事件流` : 描述的是从页面中接收事件的顺序
事件发生时会在元素节点之间按照特定的顺序传播 , 这个传播过程即
`DOM事件流`
比如:我们给页面中的一个div注册了单击事件 , 当你单击了div时 , 也就单击了body , 单击了html , 单击了document.


事件冒泡:IE最早提出 , 事件开始时由最具体的元素接收 , 然后逐级向上传播到DOM最顶层节点的过程
事件捕获:网景最早提出 , 由DOM最顶层结点开始 , 逐级向下传播到最具体的元素接收的过程

DOM事件流会经历三个阶段:
1. 捕获阶段 
2. 当前目标阶段
3. 冒泡阶段


## 事件对象