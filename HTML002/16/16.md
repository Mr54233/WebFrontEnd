# 16

原生 JavaScript 不是传统意义上的面向对象编程语言
原生 JavaScript 是利用 js 的特性 , 模拟出来的面向对象

# 构造函数和原型

## 对象的三种创建方式-- 复习

1. 字面量方式

```js
var obj = {};
```

2. new 关键字

```js
var obj = new Object{};
```

3. 构造函数方式

```js
function Person(name, age) {
	this.name = name;
	this.age = age;
}
var obj = new Person("zs", 12);
```

## 实例成员和静态成员

1. 实例成员

在构造函数中定义的属性和方法都是实例成员 , 每个对象都有自己的实例成员

实例成员就是构造函数内部通过 this 添加的成员 如下列代码中 `uname age sing` 就是实例成员 , 实例成员只能通过实例化的对象来访问

```js
function Star(uname, age) {
	this.uname = uname;
	this.age = age;
	this.sing = function () {
		console.log("我会唱歌");
	};
}
var ldh = new Star("刘德华", 18);
console.log(ldh.uname); //实例成员只能通过实例化的对象来访问
```

2. 静态成员

直接定义在构造函数上的属性和方法就是静态成员 (静态属性和静态方法)
静态属性和静态方法是属于类的 , 访问方法 : `构造函数名.属性名`
每个对象都可以通过`构造函数名.属性名`方式来读取|设置属性值
静态成员是所有对象共享的 , 实例成员是每个对象自己独享的

## 构造函数的问题

构造函数的方法很好用 , 但是存在浪费内存的问题

```js
function Star(uname, age) {
	this.uname = uname;
	this.age = age;
	this.sing = function () {
		console.log("我会唱歌");
	};
}
var ldh = new Star("刘德华", 18);
var ldh = new Star("张学友", 19);
```

## 构造函数原型 prototype

原生js 中定义一个类 : 在构造函数上定义类的属性: 类的方法定义在构造函数的原型对象上
构造函数通过原型分配的函数是所有对象所共享的.
`JavaScript` 规定 , 每个构造函数都有一个 `prototype` 属性 , 指向另一个对象.

> 注意:这个 `prototype` 也是一个对象 , 这个对象的所有属性和方法 , 都会被构造函数所拥有

我们可以把那些不变的方法, 直接定义在 prototype 对象上 , 这样所有对象的实例就可以共享这些方法

## 对象原型
对象都会有一个属性`__proto__`指向构造函数的prototype 原型对象 ， 之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法 ， 就是因为对象有 `__proto__` 原型的存在。

`__proto__`对象原型和原型对象 `prototype` 是等价的

`__proto__`对象原型的意义就在于为对象的查找机制提供一个方向或者说一条路线 , 但是它是一个非标准属性 , 因此实际开发总 , 不可以使用这个属性 , 它只是内部指向原型对象 prototype

![]()

通过对象名调用方法 ， 先在对象自己的内存中查找这个方法 ， 如果没有那么就沿着对象的`__proto__`到构造函数的原型对象的内存空间中查找方法

![](../img/prototype%E5%8E%9F%E5%9E%8B.png)


![]()


## constructor构造函数
## 以原型为扩展的

## call() 和 apply()
### call()
调用函数时 , 想要改变掉函数内部this指针指向的对象, 必须使用call或者apply来调用函数
第一个参数就是this需要指向的对象
```js
var stu = {
            name : "zhangsan"
}
var m = getMax.call(stu,100,200,500)
console.log('m',m)
```
### apply()

# 继承

## 子构造函数继承父构造函数中的属性
1. 先定义一个父构造函数
2. 再定义一个子构造函数
3. 子构造函数继承父构造函数的属性(使用call方法)
```js
// 1. 父构造函数
function Father(uname,age){
    // this指向父构造函数的对象实例
    // 使用call 调用父类的构造函数
    Person.call(this, name, age);
    this.uname = uname;
    this.age = age
}
```
子类继承父类的方法 , 设置子类构造函数的原型对象是一个父类的对象
```js
// 2. 设置子类构造函数的原型对象是一个父类的对象
Engineer.prototype = new Person()
```


# Object.defineProperty

# 获取对象的属性名

# ES6 新增方法
