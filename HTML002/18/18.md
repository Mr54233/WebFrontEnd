# 18 ES6

# ES6 简介

## 什么是 ES6

ES 的全称是 ECMAScript ， 它是由 ECMA 国际标准化组织 ，指定的一项脚本语言的标准化规范
|年份|版本|
|-|-|
|2015 年 6 月|ES2015 ES5
|2016 年 6 月|ES2016 ES6
|2017 年 6 月|ES2014
|2018 年 6 月|ES2018
|...|...|

## 为什么使用 ES6

每一次标准的诞生都意味着语言的完善 , 功能的加强 , JavaScript 语言本身也有一些令人不满意的地方 .

-   变量提升特性增加了程序运行时的不可预测性
-   语法过于松散 , 实现相同的功能 , 不同的人可能会写出不同的代码

# ES6 新增语法

## let

ES6 中新增了用于声明变量的关键字

### 1. let 声明的变量只在所处于的块级有效

```js
if (true) {
	let a = 10;
}
console.log(a); // a is not defined
```

注意：使用 let 关键字声明的变量才具有块级作用域，使用 var 声明的变量不具备块级作用域特性。

### 2. 不存在变量提升

```js
console.log(a); // a is not defined
let a = 20;
```

### 3. 暂时性死区

多个变量同名 , 作用域中有效的遵循就近原则

```js
var tmp = 123;
if (true) {
	tmp = "abc";
	console.log(tmp);
	var tmp = 123;
	console.log(tmp);
}
console.log(tmp);
// abc 123 123
var tmp = 123;
if (true) {
	tmp = "abc";
	console.log(tmp);
	let tmp = 123;
	console.log(tmp);
}
console.log(tmp);
// cannot use tmp before init
```

## const

声明常量 , 常量就是值不能变化的量

### 1. 具有块级作用域

```js
if (true) {
	const a = 10;
}
console.log(a); // a is not defined
```

### 2. 声明常量时必须赋值

```js
const PI; // Missing initializer in const declaration
```

### 3. 常量赋值后，值不能修改。

```js
const PI = 3.14;
PI = 100; // Assignment to constant variable.
```

```js
const ary = [100, 200];
ary[0] = "a";
ary[1] = "b";
console.log(ary); // ['a', 'b'];
ary = ["a", "b"]; // Assignment to constant variable.
```

## let、const、var 的区别

1. 使用 `var` 声明的变量，其作用域为该语句所在的函数内，且**存在变量提升现象。**
2. 使用 `let` 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。
3. 使用 `const` 声明的是常量，在后面出现的代码中不能再修改该常量的值。

## 解构赋值

ES6 中允许从数组中提取值，按照对应位置，对变量赋值。对象也可以实现解构。

### 数组解构

```js
let [a, b, c] = [1, 2, 3];
console.log(a);
console.log(b);
console.log(c);
```

如果解构不成功，变量的值为 `undefined`。

```js
let [foo] = [];
let [bar, foo] = [1];
```

按照一定模式，从数组中或对象中提取值，将提取出来的值赋值给另外的变量。

### 对象解构

```js
let person = { name: "zhangsan", age: 20 };
let { name, age } = person;
console.log(name); // 'zhangsan'
console.log(age); // 20

let { name: myName, age: myAge } = person; // myName myAge 属于别名
console.log(myName); // 'zhangsan'
console.log(myAge); // 20
```

对象的解构赋值是按照 `属性名 == 变量名` 来赋值的

## 箭头函数

回调函数作为另一个函数的参数 , 整个代码中也只是在这里用一次
此时在 ES6 中考虑精简 : 箭头函数

```js
var nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];
var result = nums.filter((val) => val % 2 != 0);
console.log(result);
```

## 剩余参数

### 剩余参数做形参和数组做形参

大多数概念是相同的 , 不同的地方在于

1. 调用格式不同 : sum([1,2,3]) , sum(1,2,3)
2. 如果没有参数 : sum([]) , sum()

```js
function sum(...nums) {
	var total = 0;
}
```

### 剩余参数和解构配合使用

```js
let students = ["wangwu", "zhangsan", "lisi"];
let [s1, ...s2] = students;
console.log(s1); // 'wangwu'
console.log(s2); // ['zhangsan', 'lisi']
```

# ES6 内置对象扩展
