- [Express 中间件](#express-中间件)
	- [中间件的概念](#中间件的概念)
		- [什么是中间件](#什么是中间件)
		- [现实生活中的例子](#现实生活中的例子)
		- [Express 中间件的调用流程](#express-中间件的调用流程)
		- [Express 中间件的格式](#express-中间件的格式)
		- [next 函数的作用](#next-函数的作用)
	- [Express 中间件的初体验](#express-中间件的初体验)
		- [1. 定义中间件函数](#1-定义中间件函数)
		- [2. 全局生效的中间件](#2-全局生效的中间件)
		- [3. 定义全局中间件的简化形式](#3-定义全局中间件的简化形式)
		- [4. 中间件的作用](#4-中间件的作用)
		- [5. 定义多个全局中间件](#5-定义多个全局中间件)
		- [6. 局部生效的中间件](#6-局部生效的中间件)
		- [7. 定义多个局部中间件](#7-定义多个局部中间件)
		- [8. 了解中间件的五个使用注意事项](#8-了解中间件的五个使用注意事项)
	- [中间件的分类](#中间件的分类)
		- [1. 应用级别的中间件](#1-应用级别的中间件)
		- [2. 路由级别的中间件](#2-路由级别的中间件)
		- [3. 错误级别的中间件](#3-错误级别的中间件)
		- [4. Express 内置的中间件](#4-express-内置的中间件)
		- [5. 第三方的中间件](#5-第三方的中间件)
		- [自定义中间件](#自定义中间件)
			- [1. 需求描述与实现步骤](#1-需求描述与实现步骤)
			- [2. 定义中间件](#2-定义中间件)
			- [3. 监听 req 的 data 事件](#3-监听-req-的-data-事件)
			- [4. 监听 req 的 end 事件](#4-监听-req-的-end-事件)
			- [5. 使用 querystring 模块解析请求体数据](#5-使用-querystring-模块解析请求体数据)
			- [6. 将解析出来的数据对象挂载为 req.body](#6-将解析出来的数据对象挂载为-reqbody)
			- [7. 将自定义中间件封装为模块](#7-将自定义中间件封装为模块)
- [其他](#其他)
	- [重点的经验教训](#重点的经验教训)
	- [创建中间件](#创建中间件)

# Express 中间件

## 中间件的概念

### 什么是中间件

中间件(Middleware) , 特指业务流程的中间处理环节

### 现实生活中的例子

在处理污水的时候 , 一般都要经过三个处理环节 , 从而保证处理过后的污水 , 达到排放标准

![](../img/污水处理.png)

处理污水的这三个中间处理环节 , 就叫做中间件.

### Express 中间件的调用流程

当一个请求到达 Express 服务器之后 , 可以连续调用多个中间件 , 从而对这次请求进行预处理

![](../img/中间件请求.png)

### Express 中间件的格式

Express 的中间件 , 本质上就是一个 function 处理函数 , Express 中间件的格式如下:

![](../img/中间件函数.png)

> 注意: 中间件函数的形参列表中 , 必须包含 next 参数 , 而路由处理函数中只包含 req 和 res.

### next 函数的作用

next 函数是实现多个中间件连续调用的**关键** ,它表示把流转关系转交给下一个中间件或路由

![](../img/next函数.png)

## Express 中间件的初体验

### 1. 定义中间件函数

可以通过如下方式 , 定义一个最简单的中间件函数

```js
// 常量mw 所指向的 , 就是一个中间件函数
const mw = function (req, res, next) {
	console.log("这是一个最简单的中间件函数");

	// 注意 : 在当前中间件的业务处理完毕后 , 必须调用 next() 函数
	// 表示把流转关系转交给下一个中间件或路由
	next();
};
```

### 2. 全局生效的中间件

客户端发起的任何请求 , 到达服务器之后 ,都会触发的中间件 , 叫做全局生效的中间件 .

通过调用 app.use(中间件函数) , 即可定义一个全局生效的中间价 , 示例代码如下:

```js
const mw = function (req, res, next) {
	console.log("这是一个最简单的中间件函数");
	next();
};

// 全局生效的中间件
app.use(mw);
```

### 3. 定义全局中间件的简化形式

```js
// 全局生效的中间价
app.use(function (req, res, next) {
	console.log("这是一个最简单的中间件函数");
	next();
});
```

### 4. 中间件的作用

多个中间件之间 , 共享同一份 req 和 res . 基于这样的特性 , 我们可以在上游的中间件中 , 统一为 req 或 res 对象添加自定义的属性或方法 , 供下游的中间件或路由进行使用.

![](../../img/中间件的作用.png)

### 5. 定义多个全局中间件

可以使用 app.use() 连续定义多个全局中间件 . 客户端请求到达服务器之后 , 会按照中间件定义的先后顺序依次进行调用 , 示例代码如下 :

```js
app.use(function (req, res, next) {
	// 第一个全局中间件
	console.log("调用了第一个全局中间件");
	next();
});
app.use(function (req, res, next) {
	// 第二个全局中间件
	console.log("调用了第二个全局中间件");
	next();
});

app.get("/user", (req, res) => {
	// 请求这个路由 , 会依次触发上述两个全局中间件
	res.send("User page");
});
```

### 6. 局部生效的中间件

不使用 app.use() 定义的中间件 , 叫做局部生效的中间件 , 示例代码如下 :

```js
const mw1 = function (req, res, next) {
	console.log("这是中间件函数");
	next();
};
// mw1 这个中间件只在"当前路由中生效" , 这种用法属于"局部生效的中间件"
app.get("/", mw1, function (req, res) {
	res.send("Home page");
});
// mw1 这个中间件不会影响下面这个路由
app.get("/user", function (req, res) {
	res.send("User page.");
});
```

### 7. 定义多个局部中间件

可以在路由中 , 通过如下两种等价的方式 , 使用多个局部中间件 :

```js
// 以下两种写法是'完全等价' 的 , 可根据自己的喜好 , 选择任意一种方式进行使用
app.get("/", mw1, mw2, (req, res) => {
	res.send("Home page");
});
app.get("/", [mw1, mw2], (req, res) => {
	res.send("Home page");
});
```

### 8. 了解中间件的五个使用注意事项

1. 一定要在路由之前注册中间件
2. 客户端发送过来的请求 , 可以连续调用多个中间件进行处理
3. 执行完中间件的业务代码之后 , 不要忘记调用 next() 函数
4. 为了防止代码逻辑混乱 , 调用 next() 函数后不要再写额外的代码
5. 连续调用多个中间件时 , 多个中间件之间 , 共享 req 和 res 对象

## 中间件的分类

为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是：

-   应用级别的中间件
-   路由级别的中间件
-   错误级别的中间件
-   Express 内置的中间件
-   第三方的中间件

### 1. 应用级别的中间件

通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件，叫做应用级别的中间件，代码示例如下：

```js
// 应用级别的中间件(全局中间件)
app.use((req, res) => {
	next();
});

// 应用级别的中间件(局部中间件)
app.get("/", mw1, (req, res) => {
	res.send("Home page");
});
```

### 2. 路由级别的中间件

绑定到 express.Router() 实例上的中间件 , 叫做路由级别的中间件 . 它的用法和应用级别中间件没有任何区别 , 只不过 , 应用级别中间件是绑定到 app 实例上 , 路由级别中间件绑定到 router 实例上 , 代码示例如下

```js
var app = express();
var router = express.Router();

// 路由级别的的中间件
router.use(function (req, res, next) {
	console.log("time", Data.now());
	next();
});

app.use("/", router);
```

### 3. 错误级别的中间件

错误级别中间件的作用：专门用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题。

格式：错误级别中间件的 function 处理函数中，必须有 4 个形参，形参顺序从前到后，分别是 (**err**, req, res, next)。

```js
app.get("/", function (req, res) {
	// 路由
	throw new Error("服务器内部发生了错误!"); // 抛出一个自定义的错误
	res.send("Home page");
});

app.use(function (err, req, res, next) {
	// 错误级别的中间件
	console.log("发生了错误:" + err.message); // 在服务器打印错误消息
	res.send("Error!" + err.message); // 向客户端响应错误相关的内容
});
```

> 注意：错误级别的中间件，必须注册在所有路由之后！

### 4. Express 内置的中间件

自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：

1. `express.static` 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性问题）
2. `express.json` 解析 JSON 格式的请求体数据（有兼容性问题，仅在 4.16.0+ 版本中可用）
3. `express.urlencoded` 解析 URL-encoded 格式的请求体数据（有兼容性问题，仅在 4.16.0+ 版本中可用）

```js
// 配置解析 application/json 格式数据的内置中间件
app.use(express.json());
// 配置解析 application/x-www-form-urlencoded 格式数据的内置中间件
app.use(express.urlencoded({ extended: false }));
```

### 5. 第三方的中间件

非 Express 官方内置的，而是由第三方开发出来的中间件，叫做第三方中间件。在项目中，大家可以按需下载并配置第三方中间件，从而提高项目的开发效率。
例如：在 express@4.16.0 之前的版本中，经常使用 body-parser 这个第三方中间件，来解析请求体数据。使用步骤如下：

1. 运行 `npm install body-parser` 安装中间件
2. 使用 `require` 导入中间件
3. 调用 `app.use()` 注册并使用中间件

注意：Express 内置的 express.urlencoded 中间件，就是基于 body-parser 这个第三方中间件进一步封装出来的。

### 自定义中间件

#### 1. 需求描述与实现步骤

自己手动模拟一个类似于 express.urlencoded 这样的中间件，来解析 POST 提交到服务器的表单数据。

实现步骤：

1. 定义中间件
2. 监听 req 的 data 事件
3. 监听 req 的 end 事件
4. 使用 `querystring` 模块解析请求体数据
5. 将解析出来的数据对象挂载为 req.body
6. 将自定义中间件封装为模块

#### 2. 定义中间件

使用 app.use() 来定义全局生效的中间件，代码如下：

```js
app.use(function (req, res, next) {
	// 中间件的业务逻辑
});
```

#### 3. 监听 req 的 data 事件

在中间件中，需要监听 req 对象的 data 事件，来获取客户端发送到服务器的数据。
如果数据量比较大，无法一次性发送完毕，则客户端会把数据切割后，分批发送到服务器。所以 data 事件可能会触发多次，每一次触发 data 事件时，获取到数据只是完整数据的一部分，需要手动对接收到的数据进行拼接。

```js
// 定义变量 , 用来存储客户端发送过来的请求体数据
let str = ''
// 监听 req 对象的 data 事件 (客户端发送过来的新的请求体数据)
req.on('data',(chunk) =>{
	// 拼接请求体数据 , 隐式转换为字符串
	str += chunk
})
```
#### 4. 监听 req 的 end 事件

当请求体数据接收完毕之后，会自动触发 req 的 end 事件。
因此，我们可以在 req 的 end 事件中，拿到并处理完整的请求体数据。示例代码如下：

```js
// 监听 req 对象的 end 事件 (请求体发送完毕后自动触发)
req.on('end',()=>{
	// 打印完整的请求体数据
	console.log(str)
	// TODO : 把字符串格式的请求体数据 ,解析成对象格式
})
```

#### 5. 使用 querystring 模块解析请求体数据

Node.js 内置了一个 `querystring` 模块，专门用来处理查询字符串。通过这个模块提供的 parse() 函数，可以轻松把查询字符串，解析成对象的格式。示例代码如下：
```js
// 导入处理 querystring 的Node.js 内置模块
const qs = require('querystring')
// 调用qs.parse() 方法 , 把查询字符串解析为对象
const body = qs.parse(str)
```

#### 6. 将解析出来的数据对象挂载为 req.body

上游的中间件和下游的中间件及路由之间，共享同一份 req 和 res。因此，我们可以将解析出来的数据，挂载为 req 的自定义属性，命名为 req.body，供下游使用。示例代码如下：

```js
req.on('end',()=>{
	const body = qs.parse(str) // 调用qs.parse() 方法 , 把查询字符串解析为对象
	req.body = body  // 将解析出来的请求体 , 挂在为 req.body 属性
	next() // 最后 ,一定要调用next() 函数 , 执行后续的业务逻辑
})
```

#### 7. 将自定义中间件封装为模块

为了优化代码的结构，我们可以把自定义的中间件函数，封装为独立的模块，示例代码如下：

```js
// custom-body-parser.js 模块中的代码
const qs = require('querystring')
function bodyParser(req,res,next){
	// code here
}
module.exports = bodyParser // 向外导出解析请求体数据的中间件函数
```

```js
// 1. 导入自定义的中间件模块
const myBodyParser = require('custom-body-parser')
// 2. 注册自定义的中间件模块
app.use(myBodyParser)
```

# 其他

在多个地址的请求处理中有一些通用的功能
为了避免出现重复性的代码 , 这些通用的功能使用中间件来处理
比如 : 从请求中拆分出浏览器提交的数据

## 重点的经验教训

中间件中每种情况都要有清晰的流向

## 创建中间件

1. 导入 express
2. 创建 web 服务器实例
3. 挂载中间件
4. 挂载路由
5. 启动服务器
