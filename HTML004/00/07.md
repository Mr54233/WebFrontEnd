- [day3 vue 基础入门 - part2](#day3-vue-基础入门---part2)
  - [过滤器和侦听器](#过滤器和侦听器)
    - [过滤器](#过滤器)
      - [私有过滤器和全局过滤器](#私有过滤器和全局过滤器)
      - [连续调用多个过滤器](#连续调用多个过滤器)
      - [过滤器传参](#过滤器传参)
      - [过滤器的兼容性](#过滤器的兼容性)
    - [侦听器](#侦听器)
      - [什么是 watch 侦听器](#什么是-watch-侦听器)
    - [1. 方法格式的侦听器](#1-方法格式的侦听器)
    - [2. 对象格式的侦听器](#2-对象格式的侦听器)
  - [计算属性的用法](#计算属性的用法)
    - [1. 什么是计算属性](#1-什么是计算属性)
  - [axios](#axios)
    - [axios 的基础语法](#axios-的基础语法)
  - [vue-cli 的安装和使用](#vue-cli-的安装和使用)
    - [单页面应用程序](#单页面应用程序)
      - [1. 什么是单页面应用程序](#1-什么是单页面应用程序)
      - [2. 什么是 vue-cli](#2-什么是-vue-cli)
      - [3. 安装和使用](#3-安装和使用)

# day3 vue 基础入门 - part2

## 过滤器和侦听器

### 过滤器

过滤器(filters)是 vue 为开发者提供的功能 , 常用于文本的格式化 .

过滤器可以用在两个地方:插值表达式 和 v-bind 属性绑定

过滤器应该被添加在 JavaScript 表达式的尾部 , 由"管道符"进行调用

```html
<!-- 在爽滑括号中使用"管道符"进行调用 capitalize 过滤器 , 对message的值进行格式化 -->
<p>{{message | capitalize}}</p>

<!-- 在v-bind 中通过"管道符"调用 formatId过滤器 , 对rawId的值进行格式化 -->
<div v-bind:id="rawId | formatId"></div>
```

> 注意: 要定义到 filters 节点下 , 本质上是个函数
> 注意: 在过滤器函数中 , 一定要有返回值
> 注意: 过滤器形参中 , 就可以获取到管道符前面的待处理的值
> 注意: 如果全局过滤器和私有过滤器名字一致 , 按照就近原则调用的是私有过滤器

#### 私有过滤器和全局过滤器

-   全局过滤器

在 filters 节点下定义的过滤器, 成为私有过滤器 , 因为它只有在当前 vm 示例所控制的 el 区域内使用 , 如果希望在多个 vue 实例之间共享过滤器 , 则可以按照以下的格式定义全局过滤器

```js
// 过滤器函数的第一个形参value , 记录了需要进行格式化的数据
Vue.filter("upper", function (value) {
	return value.charAt(0).toUpperCase() + value.substring(1).toLowerCase();
});
```

Vue.filter 方法接受两个参数

-   第一个参数是全局过滤器的名字
-   第二个参数是全局过滤器的处理函数

-   私有过滤器

```js
filters: {
  // 过滤器的第二个形参就记录了调用时传递过来的第一个参数
  // 一般是格式字符串
  dateFormat(value, formatter) {
    var now = new Date(value);
    var y = now.getFullYear();
    var m = now.getMonth() + 1;
    m = m < 10 ? "0" + m : m;
    var d = now.getDate();
    d = d < 10 ? "0" + d : d;

    return y + "年" + m + "月" + d + "日";
  },
},
```

#### 连续调用多个过滤器

过滤器可以串联的进行调用

先 A 后 B , A 处理完再交给 B

```html
{{ message | filterA | filterB}}
```

#### 过滤器传参

过滤器的本质是 JavaScript 函数 , 因此可以接收参数 ,

第一个参数, 永远都是管道符之前待处理的值

第二个参数开始, 才是调用过滤器时传递过来的 arg1 和 arg2 参数

```js
Vue.filter("filterA", (msg, arg1, arg2) => {
	// 过滤器的代码逻辑...
});
```

#### 过滤器的兼容性

过滤器仅在 vue2.x 和 1.x 中受支持 , 在 vue3.x 中剔除了过滤器相关的功能

在企业及项目开发中;

-   如果使用的时 2.x 版本的 vue , 则依然可以使用过滤器相关的功能
-   如果项目已经升级到了 vue3 , 官方建议使用计算属性或方法替代被提出的过滤器功能

### 侦听器

#### 什么是 watch 侦听器

watch 侦听器允许开发者监视数据的变化 ， 从而针对数据的变化做特定的操作。

```js
const vm = new Vue({
	el: "#app",
	data: { username: "" },
	watch: {
		// 监听username值的变化
		// newVal是变化后的新值 , oldVal是变化之前的旧值
		username(newVal, oldVal) {
			console.log(newVal, oldVal);
		},
	},
});
```

### 1. 方法格式的侦听器

-   缺点 1 : 无法在刚进页面的时候 , 自动触发
-   缺点 2 : 如果侦听的是一个对象 , 如果对象中的属性发生了变化 , 不会触发侦听器

### 2. 对象格式的侦听器

-   好处 1 : 可以通过 immediate 选项 , 让侦听器自动触发
    -   immediate 的作用是控制侦听器自动触发 , 默认为 false
-   好处 2 : 可以通过 deep 选项 , 让侦听器深度监听对象中每个属性的变化

## 计算属性的用法

### 1. 什么是计算属性

计算属性指的是通过一系列运算之后 , 最终得到一个属性值 .

这个动态计算出来的属性值可以被模板结构或者 methods 方法使用 ,

所有计算属性都要定义到 computed 节点下

计算属性在定义的时候要定义为"方法格式"

计算属性有缓存 , 条件没变多次调用只会计算一次

可以节约算力资源

使用的时候 , 当成普通的属性使用即可

好处:

1. 实现了代码复用
2. 只要计算属性中依赖的数据源变化了 , 则计算属性会自动重新求值

```js
computed:{
    // 计算属性的定义就是定义一个函数
    com(){
        console.log("computed");
        // 基于模型数据进行较为复杂的计算
        return this.msg.split('').reverse().join('');
    }
}
```

## axios

axios 是前端圈, 最火 , 最专注于数据请求的库

### axios 的基础语法

```js
axios({
	method: "请求的类型",
	url: "请求的URL地址",
}).then((result) => {
	// .then 用来指定请求成功之后的回调函数
	// 形参中的result 是请求成功之后的结果
});
```

使用解构赋值的时候, 使用 : 进行重命名

1. 调用 axios 之后 , 使用 async/await 进行简化
2. 使用解构赋值 , 从 axios 封装的大对象中 , 把 data 属性解构出来
3. 把解构出来的 data 属性 , 使用冒号进行重命名 , 一般重命名为{data:res}

## vue-cli 的安装和使用

### 单页面应用程序

#### 1. 什么是单页面应用程序

单页面应用程序 (Single Page Application) 简称:SPA , 顾名思义 , 指的是一个 Web 网站中只有一个唯一的一个 HTML 页面 , 所有功能与交互都在这唯一的一个页面里完成

![]()

#### 2. 什么是 vue-cli

vue-cli 是 vuejs 开发的标准工具 , 它简化了程序员基于 webpack 创建工程化的 vue 项目的过程

#### 3. 安装和使用

vue-cli 是 npm 上的一个全局包 , 使用 npm install 命令 , 即可方便的把它安装到自己的电脑上 :

`npm install @vue/cli -g`

基于 vue-cli 快速生成工程化的 vue 项目 :

`vue create 项目的名称`
