## 组合式API-setup选项
setup选项的写法和执行时机
```js
export default {
    setup(){
        // 写在这里面
        // 在beforeCreate之前
    },
    beforeCreate(){
        
    }
}
```

**setup中的this指向undefined**

```js
export default {
    setup(){
        // 数据
        const message = "this is message"
        // 函数
        const logMessage = ()=>{
            console.log(message)
        }
        // 必须以对象的方式，return出去才能使用
        return {
            message,
            logMessage
        }
    },
}

```

### script setup语法糖
简化语法
```js
<script setup>
    const message = 'this is message'
    const logMessage = ()=>{
        console.log(message)
    }
</script>
```

## 组合式API - reactive和ref函数

### reactive（）
作用：接收对象类型数据的参数传入并返回一个响应式的对象

```js
script setup
// 导入
import (reactive)from 'vue'

// 执行函数 传入参数 变量接收
const state = reactive(对象类型数据)

```
1. 从vue包中导入reactive函数
2. 在`<script setup>`执行reactive函数并传入类型为对象的初始值,并使用变量接收返回值

### ref()
作用:接收简单类型或者对象类型的数据传入并返回一个响应式的对象

```js
// 1. 导入
import {ref} from 'vue'

// 2. 执行函数 传入参数 变量接收
const count = ref(简单类型或者对象类型)

```
1. 从vue包中导入ref函数
2. 在`<script setup>`执行ref函数并传入类型为对象的初始值,并使用变量接收返回值

```js
{/* <script setup> */}

// 1. 导入ref
import {ref}  from "vue"
// 2. 执行函数 传入一个简单类型或者对象类型的参数 变量接收
const count = ref(0)

const setCount = ()=>{
  // 脚本区域修改ref产生的响应式对象数据 必须通过.value属性
  count.value++
}
// </script>

<template>
  <div>
    <!-- {{ state.count }} -->
    <!-- <button @click="state.count++">+1</button> -->
    <button @click="setCount">{{ count }}</button>
  </div>
</template>
```

推荐使用ref，功能更强大

## 计算属性函数

计算属性基本思想和vue2完全一致，组合式API下的计算数学只是修改了写法

```js
// 1. 导入computed
import {computed} from 'vue'

// 2. 执行函数 变量接收 在回调函数中return计算值
const computedState = computed(()=>{
  return 给予响应式数据做计算之后的值
})
```

1. 计算属性不应该有"副作用"
   - 比如异步请求/修改dom
2. 避免直接修改计算属性的值
   - 计算属性应该是只读的
